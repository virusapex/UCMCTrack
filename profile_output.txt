Timer unit: 1e-09 s

Total time: 0.256775 s
File: /home/viernes/UCMCTrack/tracker/ucmc.py
Function: _associate_detections_to_tracks at line 89

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    89                                               @line_profiler.profile
    90                                               def _associate_detections_to_tracks(self, dets, det_indices, track_indices, threshold, is_high_score):
    91                                                   """Associate detections to tracks using vectorized operations."""
    92       666     572463.0    859.6      0.2          if not det_indices or not track_indices:
    93       336     137271.0    408.5      0.1              if is_high_score:
    94         3       2960.0    986.7      0.0                  self.detidx_remain.extend(det_indices)
    95                                                       else:
    96       333     105182.0    315.9      0.0                  for idx in track_indices:
    97                                                               track = self.trackers[idx]
    98                                                               track.status = TrackStatus.Coasted
    99                                                               track.detidx = -1
   100       336     145877.0    434.2      0.1              return
   101                                           
   102                                                   # Prepare detection observations and covariances
   103     10490    6738976.0    642.4      2.6          det_observations = np.array([dets[idx].y for idx in det_indices]).reshape(-1, 2)
   104     10490    5928876.0    565.2      2.3          det_covariances = np.array([dets[idx].R for idx in det_indices])             # Shape: (num_dets, 2, 2)
   105                                                   # Prepare track predictions and covariances
   106     14955    9543847.0    638.2      3.7          track_predictions = np.array([[self.trackers[idx].kf.x[0], self.trackers[idx].kf.x[2]] for idx in track_indices])  # Shape: (num_tracks, 2)
   107     14955   17817656.0   1191.4      6.9          track_covariances = np.array([[[self.trackers[idx].kf.P[0, 0], self.trackers[idx].kf.P[0, 2]], [self.trackers[idx].kf.P[2, 0], self.trackers[idx].kf.P[2, 2]]] for idx in track_indices])  # Shape: (num_tracks, 2, 2)
   108                                           
   109                                                   # Compute differences between detections and tracks
   110       330    6117704.0  18538.5      2.4          diff = det_observations[:, np.newaxis, :] - track_predictions[np.newaxis, :, :]  # Shape: (num_dets, num_tracks, 2)
   111                                           
   112                                                   # Compute combined covariance matrices S for all detection-track pairs
   113       330    6691176.0  20276.3      2.6          S = det_covariances[:, np.newaxis, :, :] + track_covariances[np.newaxis, :, :, :]  # Shape: (num_dets, num_tracks, 2, 2)
   114                                           
   115                                                   # Add a small epsilon to the diagonal to ensure positive definiteness
   116       330     121249.0    367.4      0.0          epsilon = 1e-6
   117       330    3321999.0  10066.7      1.3          S[:, :, 0, 0] += epsilon
   118       330    1207121.0   3657.9      0.5          S[:, :, 1, 1] += epsilon
   119                                           
   120                                                   # Compute determinant of S
   121       330    2722247.0   8249.2      1.1          detS = S[:, :, 0, 0] * S[:, :, 1, 1] - S[:, :, 0, 1] * S[:, :, 1, 0]  # Shape: (num_dets, num_tracks)
   122                                           
   123                                                   # Handle potential zeros or negative values in detS
   124       330    4073836.0  12345.0      1.6          detS = np.where(detS <= 0, epsilon, detS)
   125       330    1501450.0   4549.8      0.6          inv_detS = 1.0 / detS
   126                                           
   127                                                   # Compute inverse of S
   128       330    1008038.0   3054.7      0.4          SI = np.empty_like(S)
   129       330    1355234.0   4106.8      0.5          SI[:, :, 0, 0] =  S[:, :, 1, 1] * inv_detS
   130       330    2242736.0   6796.2      0.9          SI[:, :, 0, 1] = -S[:, :, 0, 1] * inv_detS
   131       330    1420074.0   4303.3      0.6          SI[:, :, 1, 0] = -S[:, :, 1, 0] * inv_detS
   132       330    1075493.0   3259.1      0.4          SI[:, :, 1, 1] =  S[:, :, 0, 0] * inv_detS
   133                                           
   134                                                   # # Compute Mahalanobis distances
   135                                                   # mahalanobis = np.einsum('ijk, ijkl, ijk->ij', diff, SI, diff)  # Shape: (num_dets, num_tracks)
   136                                                   # Compute Mahalanobis distances
   137       330     248747.0    753.8      0.1          diff_expanded = diff[:, :, :, np.newaxis]  # Shape: (num_dets, num_tracks, 2, 1)
   138       330   17338573.0  52541.1      6.8          mahalanobis = np.matmul(np.transpose(diff_expanded, (0, 1, 3, 2)), SI @ diff_expanded)  # Shape: (num_dets, num_tracks, 1, 1)
   139       330     173670.0    526.3      0.1          mahalanobis = mahalanobis[:, :, 0, 0]  # Shape: (num_dets, num_tracks)
   140                                                   # Compute log determinant
   141       330    1026289.0   3110.0      0.4          logdet = np.log(detS)  # Shape: (num_dets, num_tracks)
   142                                           
   143                                                   # Compute cost matrix
   144       330     606746.0   1838.6      0.2          cost_matrix = mahalanobis + logdet  # Shape: (num_dets, num_tracks)
   145                                           
   146                                                   # Apply gating to eliminate unlikely matches (optional)
   147                                                   # gating_threshold = some_value  # You can define a gating threshold
   148                                                   # cost_matrix[cost_matrix > gating_threshold] = np.inf
   149                                           
   150                                                   # Solve the assignment problem
   151       330   49794288.0 150891.8     19.4          matched_indices, unmatched_dets, unmatched_tracks = linear_assignment(cost_matrix, threshold)
   152                                           
   153                                                   # Process matched detections and tracks
   154     10393   10526270.0   1012.8      4.1          for det_idx_i, trk_idx_j in matched_indices:
   155     10063    1807333.0    179.6      0.7              det_idx = det_indices[det_idx_i]
   156     10063    1372656.0    136.4      0.5              trk_idx = track_indices[trk_idx_j]
   157     10063    1908167.0    189.6      0.7              track = self.trackers[trk_idx]
   158     10063   88487208.0   8793.3     34.5              track.update(dets[det_idx].y, dets[det_idx].R)
   159     10063    1561131.0    155.1      0.6              track.death_count = 0
   160     10063    1422360.0    141.3      0.6              track.detidx = det_idx
   161     10063    2582507.0    256.6      1.0              track.status = TrackStatus.Confirmed
   162     10063    1644249.0    163.4      0.6              dets[det_idx].track_id = track.id
   163                                           
   164                                                   # Update unmatched detections and tracks
   165       330      88388.0    267.8      0.0          if is_high_score:
   166       330    2334524.0   7074.3      0.9              self.detidx_remain.extend(det_indices[i] for i in unmatched_dets)
   167                                                   else:
   168                                                       for trk_idx_i in unmatched_tracks:
   169                                                           trk_idx = track_indices[trk_idx_i]
   170                                                           track = self.trackers[trk_idx]
   171                                                           track.status = TrackStatus.Coasted
   172                                                           track.detidx = -1

  0.26 seconds - /home/viernes/UCMCTrack/tracker/ucmc.py:89 - _associate_detections_to_tracks
